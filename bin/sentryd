#!/usr/bin/env ruby

require 'logger'
require 'openssl'

require_relative '../lib/jsonserver'
require_relative "../lib/gpio"

$DEBUG = true

module SentryConfig
  module_eval File.read(File.join(File.dirname($0), "..", "etc", "config"))
end

class SentryServer
  def initialize(json_server)
    @json_server = json_server
    @log = @json_server.log
    @lock = GPIO.new(SentryConfig::GPIO::LOCK, :low)
    @unlock = GPIO.new(SentryConfig::GPIO::UNLOCK, :low)
    @locked = GPIO.new(SentryConfig::GPIO::LOCKED, :in, :both)
    @unlocked = GPIO.new(SentryConfig::GPIO::UNLOCKED, :in, :both)
    @door = GPIO.new(SentryConfig::GPIO::DOOR, :in, :both)
    @gpio_mutex = Mutex.new
    @subscribers = []
    @mutex = Mutex.new
  end
  def run()
    threads = []
    threads << Thread.new { self.monitor }
    threads << Thread.new { self.get_clients }
    threads.each { |thr| thr.join }
  end
  def subscribe(client)
    @mutex.synchronize { @subscribers << client }
  end
  def unsubscribe(client)
    @mutex.synchronize { @subscribers.delete client }
  end
  def lock()
    @gpio_mutex.synchronize do
      @lock.set
      sleep 0.5
      @lock.clear
    end
  end
  def unlock()
    @gpio_mutex.synchronize do
      @unlock.set
      sleep 0.5
      @unlock.clear
    end
  end
  def locked?()
    if @locked.value && !@unlocked.value
      return true
    elsif !@locked.value && @unlocked.value
      return false
    else
      return nil
    end
  end
  def door?()
    return @door.value
  end
  def get_clients()
    @json_server.run do |json_client|
      Thread.new { SentryClient.new(self, json_client).run }
    end
  end
  def monitor()
    poller = GPIOPoller.new([@door, @locked, @unlocked])
    poller.run() do |gpio, value|
      msg = nil
      case gpio
      when @door
        msg = {door: value}
        @log.info { "door: #{value}" }
      when @locked, @unlocked
        poller.timeout = 1
      when nil
        is_locked = self.locked?
        if is_locked != nil
          msg = {locked: is_locked}
          @log.info { "locked: #{is_locked}" }
          poller.timeout = nil
        end
      end
      @mutex.synchronize { @subscribers.each { |c| c.send msg } } if msg
    end
  end
end

class SentryClient
  def initialize(server, json_client)
    @server = server
    @json_client = json_client
    @auth = REGISTRY.lookup(@json_client.socket.peer_cert)
    LOG.info { "#{@auth} has connected" }
  end
  def run()
    send({banner: "Welcome #{@auth}"})
    @server.subscribe self
    @json_client.receive do |msg|
      case msg[:action]
      when "lock"
        if !@json_client.auth
          send({error: "Not authorized to lock"})
        elsif @server.door?
          send({error: "Door open; cannot lock"})
        elsif @server.locked?
          send({warning: "Already locked"})
        else
          send({ack: "Sending lock signal"})
          @server.lock
        end
      when "unlock"
        if !@json_client.auth
          send({error: "Not authorized to unlock"})
        elsif @server.locked === false
          send({warning: "Already unlocked"})
        else
          send({ack: "Sending unlock signal"})
          @server.unlock
        end
      when nil
      else
        send({error: "Unknown action type"})
      end
      case msg[:status]
      when "door"
        send({door: @server.door?})
      when "locked"
        send({locked: @server.locked?})
      when nil
      else
        send({error: "Unknown status type"})
      end
    end
    @server.unsubscribe self
  end
  def send(msg)
    @json_client.send msg
  end
end

class SentryRegistry
  attr_reader :openssl_store
  def initialize()
    @openssl_store = OpenSSL::X509::Store.new
    @uids = {}
  end
  def add(dirname)
    Dir.new(dirname).each { |filename|
      filename = File.join(dirname, filename)
      if File.file? filename
        cert = OpenSSL::X509::Certificate.new(File.read(filename))
        @openssl_store.add_cert cert
        @uids[cert.to_text] = File.basename(filename)
      end
    }
  end
  def lookup(cert)
    return @uids[cert.to_text]
  end
end

LOG = Logger.new(STDERR)
LOG.level = Logger::DEBUG

LOG.info(SentryConfig::Daemon::CLIENTS)

ssl_context = OpenSSL::SSL::SSLContext.new
ssl_context.cert = OpenSSL::X509::Certificate.new(File.open(SentryConfig::Daemon::CERT))
ssl_context.key = OpenSSL::PKey::RSA.new(File.open(SentryConfig::Daemon::KEY))
#ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER | OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT
ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER

REGISTRY = SentryRegistry.new
REGISTRY.add(SentryConfig::Daemon::CLIENTS)
ssl_context.cert_store = REGISTRY.openssl_store

socket_server = TCPServer.new(SentryConfig::Daemon::PORT)

ssl_server = OpenSSL::SSL::SSLServer.new(socket_server, ssl_context)
json_server = JSONServer.new(ssl_server, LOG)
sentry_server = SentryServer.new(json_server)
sentry_server.run
