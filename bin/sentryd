#!/usr/bin/env ruby

require 'logger'
require 'openssl'

require_relative '../lib/jsonserver'
require_relative "../lib/gpio"

$DEBUG = true
module SentryConfig
  module_eval File.read(File.join(File.dirname($0), "..", "etc", "config"))
end

class Door
  def initialize()
    @SIGNAL_DURATION = 0.5
    @LOCKING_TIMEOUT = 2
    @lock = GPIO.new(SentryConfig::GPIO::LOCK, :low)
    @unlock = GPIO.new(SentryConfig::GPIO::UNLOCK, :low)
    @locked = GPIO.new(SentryConfig::GPIO::LOCKED, :in, :both)
    @unlocked = GPIO.new(SentryConfig::GPIO::UNLOCKED, :in, :both)
    @opened = GPIO.new(SentryConfig::GPIO::OPENED, :in, :both)
    @poller = GPIOPoller.new([@opened, @locked, @unlocked])
    @mutex = Mutex.new
    @was_locked = nil
  end
  def lock()
    @mutex.synchronize do
      @lock.set; sleep @SIGNAL_DURATION; @lock.clear
    end
  end
  def unlock()
    @mutex.synchronize do
      @unlock.set; sleep @SIGNAL_DURATION; @unlock.clear
    end
  end
  def locked?()
    if @locked.value && !@unlocked.value
      return true
    elsif !@locked.value && @unlocked.value
      return false
    else
      return nil
    end
  end
  def opened?()
    return @opened.value
  end
  def monitor()
    @poller.run() do |gpio, value|
      case gpio
      when @opened
        yield :opened, value
      when @locked, @unlocked
        is_locked = self.locked?
        if is_locked == nil
          @poller.timeout = @LOCKING_TIMEOUT
        else
          changed = (is_locked != @was_locked)
          @was_locked = is_locked
          @poller.timeout = nil
          yield :locked, is_locked if changed
        end
      when nil
        @poller.timeout = nil
        @was_locked = nil
        yield :locked, nil
      end
    end
  end
end

class SentryServer
  attr_reader :door
  def initialize(json_server)
    @json_server = json_server
    @log = @json_server.log
    @door = Door.new
    @subscribers = []
    @mutex = Mutex.new
  end
  def run()
    threads = []
    threads << Thread.new { self.monitor }
    threads << Thread.new { self.get_clients }
    threads.each { |thr| thr.join }
  end
  def subscribe(client)
    @mutex.synchronize { @subscribers << client }
  end
  def unsubscribe(client)
    @mutex.synchronize { @subscribers.delete client }
  end
  def get_clients()
    @json_server.run do |json_client|
      Thread.new { SentryClient.new(self, json_client).run }
    end
  end
  def monitor()
    @door.monitor() do |type, value|
      msg = {type => value}
      @log.info { "#{type} #{value.inspect}" }
      @mutex.synchronize do
        @subscribers.each { |c| c.send msg }
      end
    end
  end
end

class SentryClient
  def initialize(server, json_client)
    @server = server
    @json_client = json_client
    @auth = REGISTRY.lookup(@json_client.socket.peer_cert)
    LOG.info { "#{@auth} has connected" }
  end
  def run()
    send({banner: "Welcome #{@auth}"})
    @server.subscribe self
    @json_client.receive do |msg|
      case msg[:action]
      when "lock"
        if !@auth || !SentryConfig::Daemon::ALLOW_UNLOCK.include?(@auth)
          send({error: "Not authorized to lock"})
        elsif @server.door.opened?
          send({error: "Door open; cannot lock"})
        elsif @server.door.locked?
          send({warning: "Already locked"})
        else
          send({ack: "Sending lock signal"})
          @server.door.lock
        end
      when "unlock"
        if !@auth || !SentryConfig::Daemon::ALLOW_LOCK.include?(@auth)
          send({error: "Not authorized to unlock"})
        elsif @server.door.locked? === false
          send({warning: "Already unlocked"})
        else
          send({ack: "Sending unlock signal"})
          @server.door.unlock
        end
      when nil
      else
        send({error: "Unknown action type"})
      end
      case msg[:status]
      when "opened"
        send({opened: @server.door.opened?})
      when "locked"
        send({locked: @server.door.locked?})
      when nil
      else
        send({error: "Unknown status type"})
      end
    end
    @server.unsubscribe self
    LOG.info { "#{@auth} has disconnected" }
  end
  def send(msg)
    @json_client.send msg
  end
end

class SentryRegistry
  attr_reader :openssl_store
  def initialize()
    @openssl_store = OpenSSL::X509::Store.new
    @uids = {}
  end
  def add(dirname)
    Dir.new(dirname).each { |filename|
      filename = File.join(dirname, filename)
      if File.file? filename
        cert = OpenSSL::X509::Certificate.new(File.read(filename))
        @openssl_store.add_cert cert
        @uids[cert.to_text] = File.basename(filename)
      end
    }
  end
  def lookup(cert)
    return @uids[cert.to_text]
  end
end

LOG = Logger.new(SentryConfig::Daemon::LOG)
LOG.level = SentryConfig::Daemon::LOG_LEVEL

ssl_context = OpenSSL::SSL::SSLContext.new
ssl_context.cert = OpenSSL::X509::Certificate.new(File.open(SentryConfig::Daemon::CERT))
ssl_context.key = OpenSSL::PKey::RSA.new(File.open(SentryConfig::Daemon::KEY))
#ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER | OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT
ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER

REGISTRY = SentryRegistry.new
REGISTRY.add(SentryConfig::Daemon::CLIENTS)
ssl_context.cert_store = REGISTRY.openssl_store

socket_server = TCPServer.new(SentryConfig::Daemon::PORT)

ssl_server = OpenSSL::SSL::SSLServer.new(socket_server, ssl_context)
json_server = JSONServer.new(ssl_server, LOG)
sentry_server = SentryServer.new(json_server)
sentry_server.run
