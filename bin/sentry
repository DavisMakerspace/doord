#!/usr/bin/env ruby

module SentryConfig
  module GPIO
    LOCK = 31
    UNLOCK = 30
    LOCKED = 48
    UNLOCKED = 60
    DOOR = 51
  end
  module Daemon
    UID = Process::UID.from_name("sentry")
    GID = Process::GID.from_name("sentry")
    INPUT_MODE = 0440
    OUTPUT_MODE = 0660
  end
end

###

class GPIOException < RuntimeError; end
class GPIOSyntaxError < GPIOException; end
class GPIOReadOnlyError < GPIOException; end
class GPIONotExportedError < GPIOException; end

class GPIO
  GPIO_PATH = "/sys/class/gpio"
  DIRECTIONS = [:in, :out, :high, :low]
  EDGES = [:none, :rising, :falling, :both]
  def initialize(id)
    @id = id
    attach
  end
  def path(file)
    return "#{GPIO_PATH}/gpio#{@id}/#{file}"
  end
  def direction_path()
    return path("direction")
  end
  def value_path()
    return path("value")
  end
  def edge_path()
    return path("edge")
  end
  def exported?()
    return File.exists?(value_path)
  end
  def attach()
    if exported?
      if input?
        @value_file = File.new(value_path, "r")
      else
        @value_file = File.new(value_path, "w")
      end
    else
      @value_file = nil
    end
  end
  def export()
    File.write("#{GPIO_PATH}/export", @id)
    attach
  end
  def unexport()
    File.write("#{GPIO_PATH}/unexport", @id)
    attach
  end
  def direction()
    return File.read(direction_path).strip.to_sym
  end
  def input?()
    return direction == :in
  end
  def output?()
    return direction == :out
  end
  def direction=(d)
    raise GPIOSyntaxError.new if !DIRECTIONS.include?(d)
    File.write(direction_path, d)
    attach()
  end
  def edge()
    return File.read(edge_path).strip.to_sym
  end
  def edge=(e)
    raise GPIOSyntaxError.new if !EDGES.include?(e)
    File.write(edge_path, e)
  end
  def value()
    v = @value_file.read(1)
    @value_file.rewind()
    return v == "0" ? false : true
  end
  def value=(v)
    raise GPIOReadOnlyError.new() if input?
    @value_file.write(v)
    @value_file.rewind()
  end
  def set()
    self.value = "1"
  end
  def clear()
    self.value = "0"
  end
  def poll(timeout = nil)
    r,w,ready = IO.select(nil, nil, [value_file], timeout)
    return value
  end
  attr_reader :value_file
end

DOOR_GPIO = {
  lock: GPIO.new(SentryConfig::GPIO::LOCK),
  unlock: GPIO.new(SentryConfig::GPIO::UNLOCK),
  locked: GPIO.new(SentryConfig::GPIO::LOCKED),
  unlocked: GPIO.new(SentryConfig::GPIO::UNLOCKED),
  door: GPIO.new(SentryConfig::GPIO::DOOR)
}

cmd = ARGV.shift
cmd = cmd.to_sym if cmd

def watch(label, gpio)
  while true
    value = gpio.poll
    puts "#{Time.now} #{label} = #{value}"
  end
end

case cmd
when :init
  DOOR_GPIO.each do |name, gpio|
    gpio.export()
    if [:lock, :unlock].include?(name)
      gpio.direction = :low
    else
      gpio.direction = :in
    end
    gpio.edge = :both
    gpio.value_file.chown(SentryConfig::Daemon::UID, SentryConfig::Daemon::GID)
    gpio.value_file.chmod(gpio.input? ? SentryConfig::Daemon::INPUT_MODE : SentryConfig::Daemon::OUTPUT_MODE)
  end
  STDERR.puts "initialized"
when :uninit
  DOOR_GPIO.each do |name, gpio|
    gpio.unexport()
  end
  STDERR.puts "uninitialized"
when :lock, :unlock
  default = trap(:EXIT) { DOOR_GPIO[cmd].clear() }
  DOOR_GPIO[cmd].set()
  sleep 1
  DOOR_GPIO[cmd].clear()
  trap(:EXIT, default)
when :locked, :unlocked, :door
  puts DOOR_GPIO[cmd].value
when :watch
  threads = []
  threads << Thread.new { watch("locked  ", DOOR_GPIO[:locked]) }
  threads << Thread.new { watch("unlocked", DOOR_GPIO[:unlocked]) }
  threads << Thread.new { watch("door    ", DOOR_GPIO[:door]) }
  threads.each { |thr| thr.join }
else
  STDERR.puts "usage: #{File.basename $0} <command>"
  STDERR.puts "  init     Initialize sentry functionality (must be root)"
  STDERR.puts "  uninit   Uninitialize sentry functionality (must be root)"
  STDERR.puts "  lock     Lock the deadbolt"
  STDERR.puts "  unlock   Unlock the deadbolt"
  STDERR.puts "  locked   Is the deadbolt locked?"
  STDERR.puts "  unlocked Is the deadbolt unlocked?"
  STDERR.puts "  door     Is the door open?"
  STDERR.puts "  watch    Watch status signals for lock, unlock, and door"
  exit 2
end
