#!/usr/bin/env ruby

CONFIG = '/etc/sentry/config'
LIB = '/usr/lib/sentry'

require 'logger'
require "#{LIB}/door"
require "#{LIB}/jsonserver"
require "#{LIB}/sslauthserver"
require "#{LIB}/secretstore"
require "#{LIB}/sentry"

module SentryConfig
  module_eval File.read CONFIG
end
CERT_EXT = 'pem'
$LOG = Logger.new(SentryConfig::Daemon::LOG)
$LOG.level = SentryConfig::Daemon::LOG_LEVEL

$DEBUG = true

def door()
  return Door.new(
    lock: SentryConfig::GPIO::LOCK,
    unlock: SentryConfig::GPIO::UNLOCK,
    locked: SentryConfig::GPIO::LOCKED,
    unlocked: SentryConfig::GPIO::UNLOCKED,
    opened: SentryConfig::GPIO::OPENED
  )
end

def clients_certs()
  certs = []
  Dir.glob(File.join(SentryConfig::Daemon::CLIENTS, "*.#{CERT_EXT}")).each do |filename|
    certs << File.read(filename) if File.file? filename
  end
  return certs
end

module SentryCommands
  extend self

  def clientls()
    clients_certs.each do |cert|
      x509 = OpenSSL::X509::Certificate.new cert
      x509.uids.each { |uid| puts uid }
    end
  end

  def useradd()
    client = ARGV.shift
    user = ARGV.shift
    if !client || !user
      STDERR.puts "Usage: #{$0} useradd <client> <user>"
      exit 1
    end
    id = {client: client, user: user}
    secrets = SecretStore.new SentryConfig::Daemon::SECRETS
    if secrets.exists? id
      STDERR.puts "User #{user} for client #{client} already exists"
      exit 2
    end
    secrets.add id
    puts "Added #{user} for client #{client}"
  end

  def userdel()
    client = ARGV.shift
    user = ARGV.shift
    if !client || !user
      STDERR.puts "Usage: #{$0} userdel <client> <user>"
      exit 1
    end
    secrets = SecretStore.new SentryConfig::Daemon::SECRETS
    id = {client: client, user: user}
    if !secrets.exists? id
      STDERR.puts "User #{user} for client #{client} does not exist"
      exit 2
    end
    success = secrets.remove id
    if success
      puts "Removed #{user} from client #{client}"
    else
      STDERR.puts "Removal failed"
      exit 3
    end
  end

  def server()
    socket_server = TCPServer.new(SentryConfig::Daemon::PORT)
    ssl_auth_server = SSLAuthServer.new(
      socket_server,
      File.read(SentryConfig::Daemon::CERT),
      File.read(SentryConfig::Daemon::KEY),
      clients_certs)
    json_server = JSONServer.new(ssl_auth_server)
    secrets = SecretStore.new SentryConfig::Daemon::SECRETS
    sentry_server = Sentry::Server.new(door, json_server, secrets)
    sentry_server.run
  end
end

command = ARGV.shift
if command && SentryCommands.respond_to?(command)
  SentryCommands.send command
else
  STDERR.puts "Usage: #{$0} <command> ..."
  STDERR.puts "  clientls  List all clients"
  STDERR.puts "  useradd   Add a user to a client"
  STDERR.puts "  userdel   Remove a user from a client"
  STDERR.puts "  server    Start the sentry server"
  exit 1
end
