#!/usr/bin/env ruby

module SentryConfig
  module_eval File.read(File.join(File.dirname($0), "..", "etc", "config"))
end
INPUT_MODE = 0440
OUTPUT_MODE = 0660

###
require_relative "../lib/gpio"

DOOR_GPIO = {
  lock: GPIO.new(SentryConfig::GPIO::LOCK, :low),
  unlock: GPIO.new(SentryConfig::GPIO::UNLOCK, :low),
  locked: GPIO.new(SentryConfig::GPIO::LOCKED, :in, :both),
  unlocked: GPIO.new(SentryConfig::GPIO::UNLOCKED, :in, :both),
  door: GPIO.new(SentryConfig::GPIO::DOOR, :in, :both)
}

cmd = ARGV.shift
cmd = cmd.to_sym if cmd

def watch(label, gpio)
  while true
    value = gpio.poll
    puts "#{Time.now} #{label} = #{value}"
  end
end

case cmd
when :init
  DOOR_GPIO.each do |name, gpio|
    gpio.chown(SentryConfig::Daemon::UID, SentryConfig::Daemon::GID)
    gpio.chmod(gpio.input? ? INPUT_MODE : OUTPUT_MODE)
  end
  STDERR.puts "initialized"
when :uninit
  DOOR_GPIO.each do |name, gpio|
    gpio.unexport()
  end
  STDERR.puts "uninitialized"
when :lock, :unlock
  default = trap(:EXIT) { DOOR_GPIO[cmd].clear() }
  DOOR_GPIO[cmd].set()
  sleep 1
  DOOR_GPIO[cmd].clear()
  trap(:EXIT, default)
when :locked, :unlocked, :door
  puts DOOR_GPIO[cmd].value
when :watch
  threads = []
  threads << Thread.new { watch("locked  ", DOOR_GPIO[:locked]) }
  threads << Thread.new { watch("unlocked", DOOR_GPIO[:unlocked]) }
  threads << Thread.new { watch("door    ", DOOR_GPIO[:door]) }
  threads.each { |thr| thr.join }
else
  STDERR.puts "usage: #{File.basename $0} <command>"
  STDERR.puts "  init     Initialize sentry functionality (must be root)"
  STDERR.puts "  uninit   Uninitialize sentry functionality (must be root)"
  STDERR.puts "  lock     Lock the deadbolt"
  STDERR.puts "  unlock   Unlock the deadbolt"
  STDERR.puts "  locked   Is the deadbolt locked?"
  STDERR.puts "  unlocked Is the deadbolt unlocked?"
  STDERR.puts "  door     Is the door open?"
  STDERR.puts "  watch    Watch status signals for lock, unlock, and door"
  exit 2
end
