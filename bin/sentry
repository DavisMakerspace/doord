#!/usr/bin/env ruby

CONFIG = '/etc/sentry/config'
LIB = File.realpath '../lib', File.dirname(__FILE__)

require 'logger'
require "#{LIB}/gpio"
require "#{LIB}/jsonserver"
require "#{LIB}/sslauthserver"
require "#{LIB}/secretstore"

module SentryConfig
  module_eval File.read CONFIG
end
CERT_EXT = 'pem'
LOG = Logger.new(SentryConfig::Daemon::LOG)
LOG.level = SentryConfig::Daemon::LOG_LEVEL

$DEBUG = true

class Door
  def initialize()
    @SIGNAL_DURATION = 0.5
    @LOCKING_TIMEOUT = 2
    @lock = GPIO.new(SentryConfig::GPIO::LOCK, :low)
    @unlock = GPIO.new(SentryConfig::GPIO::UNLOCK, :low)
    @locked = GPIO.new(SentryConfig::GPIO::LOCKED, :in, :both)
    @unlocked = GPIO.new(SentryConfig::GPIO::UNLOCKED, :in, :both)
    @opened = GPIO.new(SentryConfig::GPIO::OPENED, :in, :both)
    @poller = GPIOPoller.new([@opened, @locked, @unlocked])
    @mutex = Mutex.new
    @was_locked = nil
  end
  def lock()
    @mutex.synchronize do
      @lock.set; sleep @SIGNAL_DURATION; @lock.clear
    end
  end
  def unlock()
    @mutex.synchronize do
      @unlock.set; sleep @SIGNAL_DURATION; @unlock.clear
    end
  end
  def locked?()
    if @locked.value && !@unlocked.value
      return true
    elsif !@locked.value && @unlocked.value
      return false
    else
      return nil
    end
  end
  def opened?()
    return @opened.value
  end
  def monitor()
    @poller.run() do |gpio, value|
      case gpio
      when @opened
        yield :opened, value
      when @locked, @unlocked
        is_locked = self.locked?
        if is_locked == nil
          @poller.timeout = @LOCKING_TIMEOUT
        else
          changed = (is_locked != @was_locked)
          @was_locked = is_locked
          @poller.timeout = nil
          yield :locked, is_locked if changed
        end
      when nil
        @poller.timeout = nil
        @was_locked = nil
        yield :locked, nil
      end
    end
  end
end

class SentryServer
  attr_reader :door
  def initialize(json_server)
    @json_server = json_server
    @log = @json_server.log
    @door = Door.new
    @subscribers = []
    @mutex = Mutex.new
  end
  def run()
    threads = []
    threads << Thread.new { self.monitor }
    threads << Thread.new { self.get_clients }
    threads.each { |thr| thr.join }
  end
  def subscribe(client)
    @mutex.synchronize { @subscribers << client }
  end
  def unsubscribe(client)
    @mutex.synchronize { @subscribers.delete client }
  end
  def get_clients()
    @json_server.run do |json_client|
      Thread.new { SentryClient.new(self, json_client).run }
    end
  end
  def monitor()
    @door.monitor() do |type, value|
      msg = {type => value}
      @log.info { "#{type} #{value.inspect}" }
      @mutex.synchronize do
        @subscribers.each { |c| c.send msg }
      end
    end
  end
end

class SentryClient
  def initialize(server, json_client)
    @server = server
    @json_client = json_client
    @ids = @json_client.socket.uids
    @id = @ids ? @ids[0] : nil
    @secrets = SecretStore.new SentryConfig::Daemon::SECRETS
    @user = nil
    LOG.info { "#{@id} has connected" }
  end
  def run()
    send({banner: "Welcome client #{@id}"})
    @server.subscribe self
    @json_client.receive do |msg|
      case msg[:action]
      when "auth"
        user = msg[:user].to_s
        @user = @secrets.auth?({client: @id, user: user}, msg[:secret]) ? user : nil
        send({class: :auth, user: @user})
      when "lock"
        if !@user
          send({error: "Not authorized to lock"})
        elsif @server.door.opened?
          send({error: "Door open; cannot lock"})
        elsif @server.door.locked?
          send({warning: "Already locked"})
        else
          send({ack: "Sending lock signal"})
          @server.door.lock
        end
      when "unlock"
        if !@user
          send({error: "Not authorized to unlock"})
        elsif @server.door.locked? === false
          send({warning: "Already unlocked"})
        else
          send({ack: "Sending unlock signal"})
          @server.door.unlock
        end
      when nil
      else
        send({error: "Unknown action type"})
      end
      case msg[:status]
      when "opened"
        send({opened: @server.door.opened?})
      when "locked"
        send({locked: @server.door.locked?})
      when nil
      else
        send({error: "Unknown status type"})
      end
    end
    @server.unsubscribe self
    LOG.info { "#{@id} has disconnected" }
  end
  def send(msg)
    @json_client.send msg
  end
end

def clients_certs()
  certs = []
  Dir.glob(File.join(SentryConfig::Daemon::CLIENTS, "*.#{CERT_EXT}")).each do |filename|
    certs << File.read(filename) if File.file? filename
  end
  return certs
end

def cmd_list_clients()
  clients_certs.each do |cert|
    x509 = OpenSSL::X509::Certificate.new cert
    x509.uids.each { |uid| puts uid }
  end
end

def cmd_user_add()
  client = ARGV.shift
  user = ARGV.shift
  name = ARGV.shift
  email = ARGV.shift
  if !client || !user || !name || !email
    STDERR.puts "Usage: #{$0} user-add <client> <user> <name> <email>"
    exit 1
  end
  id = {client: client, user: user}
  secrets = SecretStore.new SentryConfig::Daemon::SECRETS
  if secrets.exists? id
    STDERR.puts "User #{user} for client #{client} already exists"
    exit 2
  end
  data = {name: name, email: email}
  secrets.add id, data
  puts "Added #{user} #{name.inspect} <#{email}> for client #{client}"
end

def cmd_user_rm()
  client = ARGV.shift
  user = ARGV.shift
  if !client || !user
    STDERR.puts "Usage: #{$0} user-rm <client> <user>"
    exit 1
  end
  secrets = SecretStore.new SentryConfig::Daemon::SECRETS
  id = {client: client, user: user}
  if !secrets.exists? id
    STDERR.puts "User #{user} for client #{client} does not exist"
    exit 2
  end
  success = secrets.remove id
  if success
    puts "Removed #{user} from client #{client}"
  else
    STDERR.puts "Removal failed"
    exit 3
  end
end

def cmd_server()
  socket_server = TCPServer.new(SentryConfig::Daemon::PORT)
  ssl_auth_server = SSLAuthServer.new(
    socket_server,
    File.read(SentryConfig::Daemon::CERT),
    File.read(SentryConfig::Daemon::KEY),
    clients_certs)
  json_server = JSONServer.new(ssl_auth_server, LOG)
  sentry_server = SentryServer.new(json_server)
  sentry_server.run
end

cmd = ARGV.shift
case cmd
when "list-clients"
  cmd_list_clients
when "user-add"
  cmd_user_add
when "user_rm"
  cmd_user_rm
when "server"
  cmd_server
else
  STDERR.puts "Usage: #{$0} <command> ..."
  STDERR.puts "  user-add  Add a user to a client"
  STDERR.puts "  user-rm   Remove a user from a client"
  STDERR.puts "  server    Start the sentry server"
  exit 1
end
