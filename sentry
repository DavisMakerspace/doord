#!/usr/bin/env ruby

GPIO_LOCK = 31
GPIO_UNLOCK = 30

GPIO_LOCKED = 48
GPIO_UNLOCKED = 60
GPIO_DOOR = 51

###
require 'etc'

GPIO = "/sys/class/gpio"
GPIO_INFO = {
  :lock => {:id => GPIO_LOCK, :direction => :low},
  :unlock => {:id => GPIO_UNLOCK, :direction => :low},
  :locked => {:id => GPIO_LOCKED, :direction => :in},
  :unlocked => {:id => GPIO_UNLOCKED, :direction => :in},
  :door => {:id => GPIO_DOOR, :direction => :in}
}
cmd = ARGV.shift

def value_path(name)
  return "#{GPIO}/gpio#{GPIO_INFO[name][:id]}/value"
end

def gpio_set(name)
  File.write(value_path(name), "1")
  STDERR.puts "set #{name} signal"
end

def gpio_reset(name)
  File.write(value_path(name), "0")
  STDERR.puts "reset #{name} signal"
end

def gpio_trigger(name)
  default = trap(:EXIT) { gpio_reset(name) }
  gpio_set(name)
  sleep 1
  trap(:EXIT, default)
  gpio_reset(name)
end

case cmd
when "init"
  GPIO_INFO.each do |name, info|
    File.write("#{GPIO}/export", info[:id])
    File.write("#{GPIO}/gpio#{info[:id]}/direction", info[:direction])
    value_file = File.new(value_path(name))
    value_file.chown(Etc.getpwnam("sentry").uid, Etc.getgrnam("sentry").gid)
    if info[:direction] == :in
      value_file.chmod(0440)
    else
      value_file.chmod(0660)
    end
  end
  STDERR.puts "initialized"
when "uninit"
  GPIO_INFO.each do |name, info|
    File.write("#{GPIO}/unexport", info[:id])
  end
  STDERR.puts "uninitialized"
when "lock", "unlock"
  gpio_trigger cmd.to_sym
when "locked", "unlocked", "door"
  puts File.read(value_path(cmd.to_sym))
else
  STDERR.puts "usage: #{File.basename $0} <command>"
  STDERR.puts "  init     Initialize sentry functionality (must be root)"
  STDERR.puts "  uninit   Uninitialize sentry functionality (must be root)"
  STDERR.puts "  lock     Lock the deadbolt"
  STDERR.puts "  unlock   Unlock the deadbolt"
  STDERR.puts "  locked   Is the deadbolt locked? (0|1)"
  STDERR.puts "  unlocked Is the deadbolt unlocked? (0|1)"
  STDERR.puts "  door     Is the door open? (0|1)"
  exit 2
end
